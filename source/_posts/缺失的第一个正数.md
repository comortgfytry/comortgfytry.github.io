---
title: 缺失的第一个正数
tags:
  - 算法
  - 普通数组
categories: [算法,普通数组]
keywords: 算法，数组
date: 2023-08-28 09:50:20œ
---
# 题目
给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。
 

示例 1：

输入：nums = [1,2,0]
输出：3
示例 2：

输入：nums = [3,4,-1,1]
输出：2
示例 3：

输入：nums = [7,8,9,11,12]
输出：1

# 分析
首先想到使用哈希表，但是虽然哈希表查找时间复杂度为O(1),创建哈希表时间复杂度为O(n)但是会造成O(n)级别的空间复杂度。  

但是可以发现在长度为n的数组中，最小的正整数必然出现在[1,n+1]中

那么原本的数组，我们可以用数组某个位置索引对应的值去表示该（索引+1）在原本数组中是否存在

所以
* 第一步：将<=0的数变为n+1及以上的数，这不会使数组的缺失第一个正数发生改变。
* 第二步：遍历数组，取绝对值（就是获得第一步改变后的值，第二步前面位置操作时可能改变）。如果发现有<=n且的数，那么把索引n-1对应的值修改为原值的相反数。
* 第三步：遍历数组。发现的第一个正数所对应索引+1就是最小正整数。如果没有正数，那么最小正整数为n+1

此外，上述方法是利用索引对应值来标记该索引+1是否存在。那么可以直接把索引下的值置换到对应位置下
# 题解

类哈希
```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int len = nums.length;
        for (int i = 0; i < len; i++) {
            if (nums[i] <= 0) {
                nums[i] = len + 1;    //随意设一个>=len+1的数就可以了
            }
        }

        for (int i = 0; i < len; i++) {
            int abs = Math.abs(nums[i]);
            if (abs <= len) {
                nums[abs-1] = -Math.abs(nums[abs-1]);
            }
        }

        for (int i = 0; i < len; i++) {
            if (nums[i] > 0) {
                return i+1;
            }
        }
        return len+1;
    }
}
```

置换
```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int len = nums.length;
        for (int i = 0; i < len; i++) {
            while (nums[i] <= len && nums[i] > 0 && nums[i] != nums[nums[i]-1] ) {
                int tmp = nums[nums[i] - 1];
                nums[nums[i] - 1] = nums[i];
                nums[i] = tmp;
            }
        }
        for (int i = 0; i < len; i++) {
            if (nums[i] != i+1) return i+1;
        }
        return len+1;
    }
}
```
