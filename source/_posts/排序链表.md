---
title: 排序链表
tags:
  - 算法
  - 链表
categories: [算法,链表]
keywords: 算法 链表
date: 2023-09-15 11:07:20
---
# 题目
给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。
# 分析
有两种解决方法
其一，利用递归将链表不断以二分法拆解，直到子链表只有一个节点，然后合并两个有序链表(自顶向下归并排序)

其二，首先算出链表长度，以迭代的方式，去合并每一个子链表(自底向上归并排序)

# 题解
自顶向下
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode sortList(ListNode head) {
        return sortList(head, null);
    }

    public static ListNode sortList(ListNode head, ListNode tail){
        if (head == null) {
            return head;
        }
        if (head == tail) {
            head.next = null;
            return head;
        }
        ListNode slow = head, fast = head;
        while (fast != tail && fast.next != tail) {
            slow = slow.next;
            fast = fast.next.next;
        }
        ListNode tmp = slow.next;
        ListNode l1 = sortList(head, slow);
        ListNode l2 = sortList(tmp, tail);
        return merge(l1, l2);
    }

    public static ListNode merge(ListNode head1, ListNode head2) {
        ListNode head = new ListNode(0);
        ListNode curr = head;
        while (head1 != null && head2 != null) {
            if (head1.val > head2.val) {
                curr.next = head2;
                head2 = head2.next;
            } else {
                curr.next = head1;
                head1 = head1.next;
            }
            curr = curr.next;
        }
        if (head1 != null) {
            curr.next = head1;
        } else if (head2 != null){
            curr.next = head2;
        }
        return head.next;
    }
}
```

自底向上
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode sortList(ListNode head) {
        int len = 0;
        ListNode curr = head;
        while (curr != null) {
            len ++;
            curr = curr.next;
        }
        if (len == 0 || len == 1) return head;

        ListNode res = new ListNode(0, head);
        for (int sLen = 1; sLen < len; sLen <<= 1) {
            ListNode pre = res;
            curr = res.next;
            while (curr != null) {
                ListNode head1 = curr;

                for (int i = 0; i < sLen-1 && curr.next != null; i++) {
                    curr = curr.next;
                }

                ListNode head2 = curr.next;
                curr.next = null;
                curr = head2;

                for (int i = 0; i < sLen-1 && curr != null && curr.next != null; i++) {
                    curr = curr.next;
                }

                ListNode next = null;
                if (curr != null) {
                    next = curr.next;
                    curr.next = null;
                }
                ListNode sorted = merge(head1, head2);
                pre.next = sorted;
                while (pre.next != null) {
                    pre = pre.next;
                }
                curr = next;
            }
        }
        return res.next;
    }

    public static ListNode merge(ListNode head1, ListNode head2) {
        ListNode head = new ListNode(0);
        ListNode curr = head;
        while (head1 != null && head2 != null) {
            if (head1.val > head2.val) {
                curr.next = head2;
                head2 = head2.next;
            } else {
                curr.next = head1;
                head1 = head1.next;
            }
            curr = curr.next;
        }
        if (head1 != null) {
            curr.next = head1;
        } else if (head2 != null){
            curr.next = head2;
        }
        return head.next;
    }
}
```