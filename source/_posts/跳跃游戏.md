---
title: 跳跃游戏
tags:
  - 贪心算法
  - 算法
categories: [算法,贪心算法]
keywords: '算法,贪心算法'

date: 2023-11-15 10:30:11
---
# 题目
给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。
# 分析
从左向右遍历找到目前结点及之前结点能到达的最远结点，判断是否超过尾结点

# 代码
```java
class Solution {
    public boolean canJump(int[] nums) {
        int far = 0;
        int end = nums.length - 1;
        for (int i = 0; i <= end; i++) {
            if (i <= far) {
                int tmp = i + nums[i];
                if (tmp > far) {
                    far = tmp;
                }
            }
            if (far >= end) return true;
        }
        return false;
    }
}
```

# 扩展
如果我们想要计算最小跳跃次数

从尾结点向前看，当然会选择离尾结点最远的结点作为上一个跳跃目标（因为如果选择之后的，上上个能跳，那么最远的结点上上个也能跳）
```java
class Solution {
    public int jump(int[] nums) {
        int step = 0;
        int target = nums.length - 1;
        while (target > 0) {
            for (int i = 0; i < target; i++) {
                if (nums[i] + i >= target) {
                    target = i;
                    step++;
                    break;
                }
            }
        }
        return step;
    }
}
```
但是从尾往前看，每次找最远结点都需要遍历，这样时间复杂度为O(n*n)  


那如果从前往后看，在某个结点处能走到的边界end，计算该结点和边界之间的结点能到达的最远距离，走到边界后扩充自己的边界到最远距离，相当于走了一步。

```java
class Solution {
    public int jump(int[] nums) {
        int len = nums.length;
        int end = 0;
        int far = 0;
        int step = 0;
        for (int i = 0; i < len - 1; i++) {
            far = Math.max(far, i + nums[i]);
            if (i == end) {
                end = far;
                step++;
            }
        }
        return step;
    }
}
```