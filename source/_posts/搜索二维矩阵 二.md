---
title: 搜索二维矩阵 二
tags:
  - 算法
  - 矩阵
categories: [算法,矩阵]
keywords: 算法 矩阵
date: 2023-09-03 14:50:20
---

# 题目
编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：

每行的元素从左到右升序排列。  
每列的元素从上到下升序排列。

![image](搜索二维矩阵%20二/image.png)

# 分析

查询矩阵中是否具有某个数可以直接把矩阵给遍历一遍，但是由于该矩阵每行从右到左递增，所以在每行遍历时可以使用二分查找。  
又由于从上到下每一列都是递增。可以发现，如果target比某一行的最后一个数还要大那么就要从下一行开始去遍历寻找（遍历一个数排除一行），如果target比某一行最后一个数还要大，那么就要从该行的前一列去寻找（遍历一个数排除一列）。这就是所谓的z字形查找。

# 题解

二分
```java
class Solution {
    public static boolean searchMatrix(int[][] matrix, int target) {
        int x = matrix[0].length;
        int y = matrix.length;

        for (int[] nums :
                matrix) {
            if (rowSe(nums, target) >= 0) {
                return true;
            }
        }
        return false;
    }

    public static int rowSe(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right){
            int mid = (left + right)/2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else {
                return mid;
            }
        }
        return -1;
    }
}
```

z字形查找

```java
class Solution {
    public static boolean searchMatrix(int[][] matrix, int target) {
        int x = matrix[0].length;
        int y = matrix.length;

        int col = 0;
        int row = x - 1;
        while (row >= 0 && col < y ) {
            if (matrix[col][row] == target) return true;
            else if (matrix[col][row] < target) {
                col++;
            } else {
                row--;
            }
        }
        return false;
    }

}
```