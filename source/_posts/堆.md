---
title: 堆
tags:
  - 算法
  - 堆
categories: [算法,堆]
keywords: 算法，堆
date: 2023-11-13 15:50:20
---

# 简介
* 以树的形式存在

* 堆通常分为最大堆和最小堆。在最大堆中，父节点的值总是大于或等于其子节点的值；而在最小堆中，父节点的值总是小于或等于其子节点的值。

* 堆可以使用<u>数组</u>来实现，通过简单的索引计算就可以找到父节点和子节点。堆也可以在内存中以树的形式实现，但这不是常见的方法。

* 堆有许多应用，包括<u>堆排序和优先级队列</u>

# 应用

## 定位父子节点
给一个最小堆
![image](堆/image.jpg)
```java
//heap
int[] heap = {3,4,5,5,6}
```
父节点索引：i  
左子节点索引：2*i+1  
右子节点索引：2*i+2  

## 构建堆
给定一个上述最小堆打乱后的数组,如何重新排序成为一个堆？
```java
int[] nums = {5,4,3,5,6}
```
其实只需要从下到上、从右向左遍历处理所有的非叶子节点，确保他和他的子节点满足堆即可  

<u>而非叶子节点的索引范围：[0,nums.length-1]</u>
```java
//最小堆
int len = nums.length;
```

```java
public static void buildMinHeap(int[] nums, int heapSize) {
    for(int i = heapSize/2; i >= 0; i--) {
        maxHeapify(nums, i, heapSize)
    }
}

public static void maxHeapify(int[] nums, int i, int heapSize) {
    int left = 2 * i + 1, right = 2 * i + 2, father = i;
    if (left < heapSize && nums[left] < nums[father]) {
            father = left;
        }
        if (right < heapSize && nums[right] < nums[father]) {
            father = right;
        }
        if (father != i) {
            int tmp = nums[i];
            nums[i] = nums[father];
            nums[father] = tmp;
            maxHeapify(nums, father, heapSize);
        }
}
```

## 优先队列
优先队列通常用堆实现。在优先队列中，元素被赋予优先级，优先级较高的元素先于优先级较低的元素被取出。

下面有一个问题：

给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回数组。

我们这里就可以使用优先队列，限定其长度为K。
第一步用哈希表统计数组中数出现的频率
第二步遍历哈希表的key。如果现在队列长度小于K，那么直接把key加入队列；否则先比较频率，如果key频率比队列中队首的频率高，先让队首出列，然后放入（注意：创建优先队列时，优先级要设置为频率低的先出列）

这种方法需要遍历一遍数组所以时间复杂度为O(n),但是优先堆列插入过程中会有排序所以总体的时间复杂度为O(nlog(n))
```java
class Solution {
public static int[] topKFrequent(int[] nums, int k) {
        // 统计num出现的频率
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int num : nums) {
            if (map.containsKey(num)) {
                int tmp = map.get(num);
                map.put(num, tmp+1);
            } else {
                map.put(num, 1);
            }
        }
        // 优先队列(最小堆)
        PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return map.get(o1)-map.get(o2);
            }
        });
        for (int key : map.keySet()) {
            if (pq.size() < k) {
                pq.add(key);
            } else if(map.get(key) > map.get(pq.peek())) {
                pq.remove();
                pq.add(key);
            }
        }
        // 返回堆
        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = pq.remove();
        }
        return res;
    }
}
```

如果要再优化算法的时间复杂度  
可以使用桶排序    
这样时间为O(n)  
```java
class Solution {
    public static int[] topKFrequent(int[] nums, int k) {
        // 统计频率
        HashMap<Integer,Integer> map = new HashMap();
        for(int num : nums){
            if (map.containsKey(num)) {
                map.put(num, map.get(num) + 1);
            } else {
                map.put(num, 1);
            }
        }
        //存入（以出现的频率作为索引，数组里面存的是一个list）
        List<Integer>[] lists = new List[nums.length + 1];
        for (int key: map.keySet()) {
            int i = map.get(key);
            if (lists[i] == null) {
                lists[i] = new ArrayList<>();
            }
            lists[i].add(key);
        }
        // 返回结果
        int[] res = new int[k];
        int index = 0;
        for (int i = lists.length - 1; index < k; i--) {
            if (lists[i] == null) continue;
            for(int num: lists[i]) {
                res[index] = num;
                index++;
            }
        }
        return res;
    }
}

```
